"""
Projects API Endpoints
======================

Endpoints for managing funded research projects and analyzing funding impact.

Endpoints:
- GET /api/projects - Search and list projects
- GET /api/projects/{id} - Get project details
- GET /api/projects/search/by-title - Find projects by title
- GET /api/projects/{id}/publications - Get publications from project
- GET /api/projects/stats/overview - Project statistics
- GET /api/projects/stats/funding - Funding analysis
"""

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from sqlalchemy import func, desc
from datetime import datetime
from typing import Optional

from app.database import get_db, Project, Publication, project_publication
from app.schemas import ProjectResponse

router = APIRouter(prefix="/api/projects", tags=["Projects"])


@router.get(
    "",
    response_model=dict,
    summary="Search projects",
)
async def search_projects(
    q: Optional[str] = Query(None, description="Search query (title, abstract)"),
    funder: Optional[str] = Query(None, description="Filter by funder"),
    organization_id: Optional[str] = Query(None, description="Filter by principal investigator organization"),
    limit: int = Query(50, ge=1, le=1000),
    offset: int = Query(0, ge=0),
    db: Session = Depends(get_db),
):
    """
    Search funded research projects.

    **Query Parameters:**
    - `q`: Free text search in title and abstract
    - `funder`: Filter by funding organization (FWF, FFG, etc.)
    - `organization_id`: Filter by associated organization
    - `limit`: Results per page
    - `offset`: Pagination offset

    **Response:**
    Paginated list of projects matching criteria.
    """

    query = db.query(Project)

    # Text search
    if q:
        search_term = f"%{q}%"
        query = query.filter(
            (Project.title.ilike(search_term))
            | (Project.abstract.ilike(search_term))
        )

    # Funder filter
    if funder:
        query = query.filter(Project.funder == funder)

    # Get total count before pagination
    total = query.count()

    # Sort by start date (most recent first)
    query = query.order_by(desc(Project.start_date))

    # Pagination
    projects = query.limit(limit).offset(offset).all()

    return {
        "total": total,
        "limit": limit,
        "offset": offset,
        "results": [ProjectResponse.model_validate(p).__dict__ for p in projects],
    }


@router.get(
    "/{project_id}",
    response_model=ProjectResponse,
    summary="Get project details",
)
async def get_project(
    project_id: str,
    db: Session = Depends(get_db),
):
    """
    Get detailed information about a specific project.

    **Parameters:**
    - `project_id`: Project ID or grant number

    **Response:**
    Complete project metadata with funding information and investigators.
    """

    project = db.query(Project).filter(
        (Project.id == project_id) | (Project.grant_number == project_id)
    ).first()

    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    return ProjectResponse.model_validate(project)


@router.get(
    "/{project_id}/publications",
    response_model=dict,
    summary="Get publications from project",
)
async def get_project_publications(
    project_id: str,
    limit: int = Query(50, ge=1, le=1000),
    offset: int = Query(0, ge=0),
    db: Session = Depends(get_db),
):
    """
    Get publications that resulted from a specific funded project.

    **Parameters:**
    - `project_id`: Project ID
    - `limit`: Results per page
    - `offset`: Pagination offset

    **Response:**
    List of publications generated by project funding.
    """

    # Verify project exists
    project = db.query(Project).filter(
        (Project.id == project_id) | (Project.grant_number == project_id)
    ).first()

    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    # Get publications
    from app.schemas import PublicationResponse

    query = db.query(Publication).join(
        project_publication, Publication.id == project_publication.c.publication_id
    ).filter(project_publication.c.project_id == project.id)

    total = query.count()

    publications = (
        query.order_by(desc(Publication.publication_date))
        .limit(limit)
        .offset(offset)
        .all()
    )

    return {
        "project": {
            "id": project.id,
            "title": project.title,
            "grant_number": project.grant_number,
        },
        "total_publications": total,
        "limit": limit,
        "offset": offset,
        "results": [
            PublicationResponse.model_validate(pub).__dict__ for pub in publications
        ],
    }


@router.get(
    "/search/by-title",
    response_model=dict,
    summary="Search projects by title",
)
async def search_projects_by_title(
    q: str = Query(..., description="Project title or keywords", min_length=2),
    limit: int = Query(20, ge=1, le=100),
    db: Session = Depends(get_db),
):
    """
    Find projects by title or keywords.

    **Query Parameters:**
    - `q`: Title or keywords to search for
    - `limit`: Maximum results

    **Response:**
    List of matching projects ranked by relevance.
    """

    search_term = f"%{q}%"

    projects = (
        db.query(Project)
        .filter(Project.title.ilike(search_term))
        .order_by(desc(Project.start_date))
        .limit(limit)
        .all()
    )

    return {
        "query": q,
        "total_results": len(projects),
        "results": [ProjectResponse.model_validate(p).__dict__ for p in projects],
    }


@router.get(
    "/stats/overview",
    summary="Get project statistics",
)
async def get_project_stats(db: Session = Depends(get_db)):
    """
    Get aggregate statistics about funded research projects.

    **Response:**
    - Total projects
    - Total funding amount
    - Projects by funder
    - Average project duration
    """

    total_projects = db.query(func.count(Project.id)).scalar() or 0

    # Total funding
    total_funding = db.query(func.sum(Project.funding_amount)).scalar() or 0

    # By funder
    by_funder = (
        db.query(Project.funder, func.count(Project.id).label("count"))
        .group_by(Project.funder)
        .all()
    )

    # Projects by year (start date)
    by_year = (
        db.query(
            func.year(Project.start_date).label("year"),
            func.count(Project.id).label("count"),
        )
        .filter(Project.start_date.isnot(None))
        .group_by(func.year(Project.start_date))
        .all()
    )

    return {
        "total_projects": total_projects,
        "total_funding_eur": float(total_funding) if total_funding else 0,
        "by_funder": {funder: count for funder, count in by_funder},
        "by_year": {str(year): count for year, count in by_year if year},
        "average_funding": (
            float(total_funding) / total_projects
            if total_projects > 0 and total_funding
            else 0
        ),
        "last_updated": datetime.utcnow().isoformat(),
    }


@router.get(
    "/stats/funding",
    summary="Get funding analysis and ROI metrics",
)
async def get_funding_analysis(
    funder: Optional[str] = Query(None, description="Filter by funder"),
    db: Session = Depends(get_db),
):
    """
    Analyze funding efficiency and return on investment.

    **Query Parameters:**
    - `funder`: Filter to specific funder (FWF, FFG, etc.)

    **Response:**
    Funding statistics and ROI metrics (publications per funding unit).
    """

    query = db.query(Project)

    if funder:
        query = query.filter(Project.funder == funder)

    projects = query.all()

    # Calculate metrics
    total_funding = sum(p.funding_amount or 0 for p in projects)
    total_projects = len(projects)

    # Count publications per project (linked)
    total_publications = 0
    projects_with_pubs = 0

    for project in projects:
        pub_count = (
            db.query(func.count(Publication.id))
            .join(project_publication)
            .filter(project_publication.c.project_id == project.id)
            .scalar() or 0
        )
        if pub_count > 0:
            total_publications += pub_count
            projects_with_pubs += 1

    # Calculate ROI metrics
    publications_per_million = (
        (total_publications / (total_funding / 1_000_000))
        if total_funding > 0
        else 0
    )

    avg_funding_per_publication = (
        (total_funding / total_publications)
        if total_publications > 0
        else 0
    )

    return {
        "funding_analysis": {
            "total_funding_eur": float(total_funding),
            "total_projects": total_projects,
            "total_linked_publications": total_publications,
            "projects_with_publications": projects_with_pubs,
            "publications_per_million_eur": round(publications_per_million, 2),
            "avg_funding_per_publication_eur": round(avg_funding_per_publication, 2),
            "avg_funding_per_project_eur": (
                round(total_funding / total_projects, 2) if total_projects > 0 else 0
            ),
        },
        "filter": {"funder": funder} if funder else None,
        "last_updated": datetime.utcnow().isoformat(),
    }
